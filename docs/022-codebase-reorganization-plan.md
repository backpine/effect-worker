# 022 - Codebase Reorganization Plan

## Overview

This document outlines a comprehensive reorganization of the Effect Worker codebase to improve:
1. **File naming**: kebab-case instead of camelCase
2. **Imports**: Use `@/` path aliases instead of relative imports
3. **Documentation**: Cloudflare-specific docstrings explaining "why"
4. **Structure**: Follow common Effect patterns for better navigation

---

## Current Structure (Problems)

```
src/
├── api/                          # Confusing: Only holds "Live" implementations
│   ├── groups/
│   │   ├── HealthGroupLive.ts    # camelCase, confusing name
│   │   ├── UsersGroupLive.ts     # camelCase, confusing name
│   │   └── index.ts
│   └── index.ts
├── app.ts                        # Thin wrapper, purpose unclear
├── db/
│   ├── migrations/               # Auto-generated by drizzle-kit
│   │   ├── schema.ts
│   │   └── relations.ts
│   └── schema.ts                 # Placeholder
├── definition/                   # Confusing: Mixed concerns
│   ├── WorkerApi.ts              # camelCase
│   ├── errors/
│   │   └── index.ts
│   ├── groups/
│   │   ├── HealthGroup.ts        # camelCase, just endpoint definitions
│   │   ├── UsersGroup.ts         # camelCase
│   │   └── index.ts
│   ├── schemas/
│   │   ├── User.ts               # camelCase
│   │   └── index.ts
│   └── index.ts
├── errors/                       # Empty, duplicates definition/errors
│   └── index.ts
├── handler.ts                    # Core handler, but named generically
├── services/
│   ├── cloudflare.ts             # Good name
│   ├── database.ts               # Good name
│   └── index.ts
└── worker.ts                     # Entry point
```

### Key Problems

1. **Naming**: camelCase files (`WorkerApi.ts`, `HealthGroup.ts`, etc.)
2. **Imports**: Uses `../../definition` relative paths
3. **Confusing separation**: `definition/` vs `api/` is unclear
   - Why are schemas in `definition/schemas/` but not in a shared place?
   - Why are errors duplicated (`definition/errors/` and `errors/`)?
4. **Missing context**: No docs explaining Cloudflare runtime constraints
5. **"Live" suffix**: Effect convention but confusing for newcomers

---

## Proposed Structure

```
src/
├── index.ts                      # Entry point (renamed from worker.ts)
├── runtime.ts                    # ManagedRuntime setup with docs
│
├── http/                         # HTTP API layer (replaces definition/ and api/)
│   ├── api.ts                    # HttpApi definition (WorkerApi)
│   ├── groups/                   # Endpoint definitions + implementations together
│   │   ├── health.ts             # Definition + handler for /health
│   │   ├── users.ts              # Definition + handler for /users
│   │   └── index.ts
│   ├── schemas/                  # Shared schemas for API
│   │   ├── user.ts
│   │   └── index.ts
│   ├── errors/                   # API errors (HTTP status codes)
│   │   └── index.ts
│   └── index.ts
│
├── services/                     # Request-scoped services
│   ├── cloudflare.ts             # FiberRef-based env/ctx access
│   ├── database.ts               # FiberRef-based Drizzle access
│   └── index.ts
│
├── db/                           # Database layer
│   ├── schema.ts                 # Manual schema definitions (or drizzle-kit output)
│   ├── migrations/               # Auto-generated by drizzle-kit
│   │   ├── schema.ts
│   │   └── relations.ts
│   └── index.ts
│
└── lib/                          # Shared utilities
    ├── effect.ts                 # Effect helpers (if needed)
    └── index.ts
```

---

## File Naming Convention

| Current | Proposed |
|---------|----------|
| `WorkerApi.ts` | `api.ts` |
| `HealthGroup.ts` | `health.ts` |
| `UsersGroup.ts` | `users.ts` |
| `HealthGroupLive.ts` | merged into `health.ts` |
| `UsersGroupLive.ts` | merged into `users.ts` |
| `User.ts` | `user.ts` |
| `worker.ts` | `index.ts` |
| `handler.ts` | `runtime.ts` |
| `app.ts` | removed (merged into `runtime.ts`) |

**Rule**: All files use kebab-case. No exceptions.

---

## Import Convention

All imports use `@/` path alias:

```typescript
// GOOD
import { WorkerApi } from "@/http"
import { getDrizzle } from "@/services"
import { deJobEvents } from "@/db"

// BAD
import { WorkerApi } from "../../definition"
import { getDrizzle } from "../services"
```

---

## Detailed File Contents

### `src/index.ts` (Entry Point)

```typescript
/**
 * Cloudflare Worker Entry Point
 *
 * This is the main entry point for the Cloudflare Worker. It exports a default
 * object with a `fetch` handler that processes incoming HTTP requests.
 *
 * ## Cloudflare Runtime Constraints
 *
 * - **No global state**: Each request runs in an isolated context. While the
 *   Worker runtime may reuse the same isolate, you cannot rely on global state
 *   persisting between requests.
 *
 * - **Request-scoped bindings**: Cloudflare's `env` (KV, D1, R2, etc.) and
 *   `ExecutionContext` are only available during request handling, not at
 *   module initialization time.
 *
 * - **Limited CPU time**: Workers have 10-30ms CPU time limits. Long-running
 *   computations should be avoided or broken into smaller chunks.
 *
 * ## Why FiberRef for Request-Scoped Data?
 *
 * We use FiberRef instead of Effect's Layer/Context.Tag pattern because:
 *
 * 1. **Layer memoization**: ManagedRuntime builds layers ONCE at startup.
 *    Cloudflare bindings aren't available at startup, only at request time.
 *
 * 2. **Per-request isolation**: FiberRef + Effect.locally ensures each request
 *    has its own isolated values, even when running on the same runtime.
 *
 * 3. **Type safety without placeholders**: Using FiberRef avoids the need for
 *    placeholder layers that would require "as any" casts.
 *
 * @module
 */
import { Effect } from "effect"
import { runtime, handleRequest, openApiSpec } from "@/runtime"
import { withDatabase, withEnv, withCtx } from "@/services"

const withRequestScope = (env: Env, ctx: ExecutionContext) =>
  <A, E, R>(effect: Effect.Effect<A, E, R>) =>
    effect.pipe(
      withDatabase(env.DATABASE_URL),
      withEnv(env),
      withCtx(ctx),
    )

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext) {
    const url = new URL(request.url)

    if (url.pathname === "/api/openapi.json") {
      return Response.json(openApiSpec)
    }

    const effect = handleRequest(request).pipe(withRequestScope(env, ctx))
    return runtime.runPromise(effect)
  },
}
```

### `src/runtime.ts` (Runtime Setup)

```typescript
/**
 * Effect Runtime Configuration
 *
 * This module sets up the ManagedRuntime for handling HTTP requests.
 *
 * ## Why ManagedRuntime?
 *
 * ManagedRuntime provides layer memoization, meaning services are built once
 * and reused across requests. This is efficient for:
 *
 * - Router configuration (static, doesn't change per-request)
 * - Middleware setup (static)
 * - OpenAPI generation (static)
 *
 * ## What About Request-Scoped Services?
 *
 * Request-scoped services (database, Cloudflare env) are NOT part of the
 * ManagedRuntime layer. Instead, they're provided via FiberRef + Effect.locally
 * in the request handler (see src/index.ts).
 *
 * This separation ensures:
 * - Static services: Built once, reused (efficient)
 * - Request-scoped services: Created per-request (isolated)
 *
 * @module
 */
import { Effect, Layer, ManagedRuntime } from "effect"
import { HttpApiBuilder, HttpServer, OpenApi } from "@effect/platform"
import * as ServerRequest from "@effect/platform/HttpServerRequest"
import * as ServerResponse from "@effect/platform/HttpServerResponse"
import { WorkerApi, HttpGroupsLive } from "@/http"

/**
 * API Layer combining static services
 *
 * These layers are memoized by ManagedRuntime - built once at startup.
 * Request-scoped services are provided separately via FiberRef.
 */
const ApiLayer = Layer.mergeAll(
  HttpApiBuilder.api(WorkerApi).pipe(Layer.provide(HttpGroupsLive)),
  HttpApiBuilder.Router.Live,
  HttpApiBuilder.Middleware.layer,
  HttpServer.layerContext,
)

/**
 * Shared runtime instance
 *
 * Built once at module initialization. Layers are memoized, so subsequent
 * calls to runPromise reuse the same service instances.
 */
export const runtime = ManagedRuntime.make(ApiLayer)

/**
 * Handle an incoming HTTP request
 *
 * Returns an Effect that can be wrapped with request-scoped services
 * (database, Cloudflare env/ctx) before execution.
 */
export const handleRequest = (request: Request) =>
  Effect.gen(function* () {
    const app = yield* HttpApiBuilder.httpApp
    const serverRequest = ServerRequest.fromWeb(request)

    const response = yield* app.pipe(
      Effect.provideService(ServerRequest.HttpServerRequest, serverRequest),
      Effect.scoped,
    )

    return ServerResponse.toWeb(response)
  })

/**
 * OpenAPI specification for the API
 */
export const openApiSpec = OpenApi.fromApi(WorkerApi)
```

### `src/http/api.ts` (API Definition)

```typescript
/**
 * HTTP API Definition
 *
 * This module defines the structure of the Worker's HTTP API using
 * @effect/platform's HttpApi builder.
 *
 * ## Effect HTTP API Pattern
 *
 * Effect's HttpApi system provides:
 * - Type-safe endpoint definitions with schemas
 * - Automatic request/response validation
 * - OpenAPI specification generation
 * - Composable middleware
 *
 * The API definition is separate from the implementation (handlers).
 * This allows:
 * - Client SDK generation from the API definition
 * - Documentation generation
 * - Type inference for handlers
 *
 * @module
 */
import { HttpApi } from "@effect/platform"
import { HealthGroup, UsersGroup } from "./groups"

/**
 * Worker API definition
 *
 * All endpoints are prefixed with `/api`.
 */
export class WorkerApi extends HttpApi.make("WorkerApi")
  .add(HealthGroup)
  .add(UsersGroup)
  .prefix("/api") {}
```

### `src/http/groups/health.ts` (Combined Definition + Handler)

```typescript
/**
 * Health Check Endpoint
 *
 * Provides a simple health check endpoint for monitoring and load balancers.
 * Also serves as a demonstration of accessing request-scoped services.
 *
 * ## Accessing Request-Scoped Services
 *
 * In Cloudflare Workers, we use FiberRef-based accessors instead of
 * yield* Service pattern:
 *
 * ```typescript
 * // DON'T: Creates layer dependency, breaks ManagedRuntime
 * const env = yield* CloudflareEnv
 *
 * // DO: Reads from FiberRef, no layer dependency
 * const env = yield* getEnv
 * ```
 *
 * @module
 */
import { HttpApiEndpoint, HttpApiGroup, HttpApiBuilder } from "@effect/platform"
import { Effect, Schema as S } from "effect"
import { WorkerApi } from "@/http/api"
import { getEnv, getDrizzle } from "@/services"
import { deJobEvents } from "@/db"

// ============================================================================
// Endpoint Definition
// ============================================================================

const HealthResponse = S.Struct({
  status: S.Literal("ok"),
  timestamp: S.String,
  environment: S.String,
})

export const HealthGroup = HttpApiGroup.make("health").add(
  HttpApiEndpoint.get("check", "/health").addSuccess(HealthResponse),
)

// ============================================================================
// Handler Implementation
// ============================================================================

export const HealthGroupLive = HttpApiBuilder.group(
  WorkerApi,
  "health",
  (handlers) =>
    Effect.gen(function* () {
      return handlers.handle("check", () =>
        Effect.gen(function* () {
          const env = yield* getEnv
          const drizzle = yield* getDrizzle

          // Example database query (remove in production)
          const data = yield* drizzle
            .select()
            .from(deJobEvents)
            .limit(10)
            .pipe(Effect.catchAll((error) => Effect.logError(error)))

          yield* Effect.log(data)

          return {
            status: "ok" as const,
            timestamp: new Date().toISOString(),
            environment: env.ENVIRONMENT || "development",
          }
        }),
      )
    }),
)
```

### `src/http/groups/users.ts` (Combined Definition + Handler)

```typescript
/**
 * Users Endpoints
 *
 * CRUD operations for user management.
 *
 * ## Schema Validation
 *
 * Effect Schema provides runtime validation with compile-time types:
 * - Branded types (UserId, Email) ensure type safety
 * - Pattern validation (email format) runs at request time
 * - Errors automatically become HTTP 400 responses
 *
 * @module
 */
import { HttpApiEndpoint, HttpApiGroup, HttpApiBuilder } from "@effect/platform"
import { DateTime, Effect, Schema as S } from "effect"
import { WorkerApi } from "@/http/api"
import { UserSchema, UserIdPathSchema, CreateUserSchema, UserId, Email, User } from "@/http/schemas"
import { UserNotFoundError } from "@/http/errors"

// ============================================================================
// Endpoint Definitions
// ============================================================================

const UsersListSchema = S.Struct({
  users: S.Array(UserSchema),
  total: S.Number,
})

export const UsersGroup = HttpApiGroup.make("users")
  .add(HttpApiEndpoint.get("list", "/").addSuccess(UsersListSchema))
  .add(
    HttpApiEndpoint.get("get", "/:id")
      .setPath(UserIdPathSchema)
      .addSuccess(UserSchema)
      .addError(UserNotFoundError),
  )
  .add(
    HttpApiEndpoint.post("create", "/")
      .setPayload(CreateUserSchema)
      .addSuccess(UserSchema),
  )
  .prefix("/users")

// ============================================================================
// Handler Implementation
// ============================================================================

// In-memory user store for demo purposes
const users = new Map<string, User>([
  [
    "usr_abc123",
    {
      id: "usr_abc123" as UserId,
      email: "alice@example.com" as Email,
      name: "Alice Johnson",
      createdAt: DateTime.unsafeFromDate(new Date("2024-01-01")),
    },
  ],
  [
    "usr_def456",
    {
      id: "usr_def456" as UserId,
      email: "bob@example.com" as Email,
      name: "Bob Smith",
      createdAt: DateTime.unsafeFromDate(new Date("2024-01-15")),
    },
  ],
])

let userCounter = 1000

const generateUserId = (): UserId => {
  userCounter++
  return `usr_${userCounter.toString(36)}` as UserId
}

export const UsersGroupLive = HttpApiBuilder.group(
  WorkerApi,
  "users",
  (handlers) =>
    Effect.gen(function* () {
      return handlers
        .handle("list", () =>
          Effect.succeed({
            users: Array.from(users.values()),
            total: users.size,
          }),
        )
        .handle("get", ({ path: { id } }) =>
          Effect.gen(function* () {
            const user = users.get(id)
            if (!user) {
              return yield* Effect.fail(
                new UserNotFoundError({
                  id,
                  message: `User not found: ${id}`,
                }),
              )
            }
            return user
          }),
        )
        .handle("create", ({ payload: { email, name } }) =>
          Effect.gen(function* () {
            const id = generateUserId()
            const user: User = {
              id,
              email: email as Email,
              name,
              createdAt: DateTime.unsafeNow(),
            }
            users.set(id, user)
            return user
          }),
        )
    }),
)
```

### `src/http/groups/index.ts`

```typescript
/**
 * HTTP API Groups
 *
 * This module exports all API groups (definitions + handlers).
 *
 * @module
 */
import { Layer } from "effect"
export { HealthGroup, HealthGroupLive } from "./health"
export { UsersGroup, UsersGroupLive } from "./users"

/**
 * Combined layer of all HTTP group handlers
 */
export const HttpGroupsLive = Layer.mergeAll(
  // Import dynamically to allow tree-shaking
  (await import("./health")).HealthGroupLive,
  (await import("./users")).UsersGroupLive,
)

// Or statically:
// export const HttpGroupsLive = Layer.mergeAll(HealthGroupLive, UsersGroupLive)
```

### `src/http/index.ts`

```typescript
/**
 * HTTP API Module
 *
 * Public exports for the HTTP API layer.
 *
 * @module
 */
export { WorkerApi } from "./api"
export * from "./groups"
export * from "./schemas"
export * from "./errors"
```

### `src/services/cloudflare.ts` (Enhanced Docs)

```typescript
/**
 * Cloudflare Request-Scoped Services
 *
 * Provides access to Cloudflare's `env` and `ExecutionContext` bindings
 * using Effect's FiberRef pattern.
 *
 * ## Why FiberRef Instead of Context.Tag?
 *
 * In a typical Effect application, you'd use Context.Tag + Layer:
 *
 * ```typescript
 * class CloudflareEnv extends Context.Tag("CloudflareEnv")<...>() {
 *   static layer = (env: Env) => Layer.succeed(this, { env })
 * }
 * ```
 *
 * This doesn't work with Cloudflare Workers because:
 *
 * 1. **Layer memoization**: ManagedRuntime builds layers at startup, but
 *    Cloudflare bindings aren't available until request time.
 *
 * 2. **Request isolation**: Layers are shared across requests. If we somehow
 *    injected `env` into a layer, all concurrent requests would see the same
 *    env (the first request's env).
 *
 * 3. **Type requirements**: Using Context.Tag in handlers creates a layer
 *    dependency (R type). This prevents using ManagedRuntime.make(ApiLayer)
 *    because the layer would require CloudflareEnv.
 *
 * ## FiberRef Solution
 *
 * FiberRef provides fiber-local storage that works with Effect.locally:
 *
 * ```typescript
 * // Set value for the scope of this effect
 * Effect.locally(currentEnv, env)(myEffect)
 *
 * // Read value inside the effect
 * const env = yield* FiberRef.get(currentEnv)
 * ```
 *
 * This ensures:
 * - Each request has its own isolated env/ctx values
 * - No layer dependencies (handlers have R = never)
 * - ManagedRuntime can be used for static services
 *
 * @module
 */
import { Effect, FiberRef } from "effect"

// ============================================================================
// FiberRefs for Request-Scoped Data
// ============================================================================

/**
 * FiberRef holding the current request's Cloudflare environment bindings.
 *
 * Contains KV namespaces, D1 databases, R2 buckets, secrets, and other
 * bindings defined in wrangler.toml.
 */
export const currentEnv = FiberRef.unsafeMake<Env | null>(null)

/**
 * FiberRef holding the current request's ExecutionContext.
 *
 * Used for ctx.waitUntil() to schedule background work after response.
 */
export const currentCtx = FiberRef.unsafeMake<ExecutionContext | null>(null)

// ============================================================================
// Accessors (Use These in Handlers)
// ============================================================================

/**
 * Get the current Cloudflare environment bindings.
 *
 * Dies if called outside of withEnv() scope (programming error).
 *
 * @example
 * ```typescript
 * const env = yield* getEnv
 * const value = await env.MY_KV.get("key")
 * ```
 */
export const getEnv = Effect.gen(function* () {
  const env = yield* FiberRef.get(currentEnv)
  if (env === null) {
    return yield* Effect.die(
      "Cloudflare env not set. Ensure withEnv() wraps the handler.",
    )
  }
  return env
})

/**
 * Get the current Cloudflare ExecutionContext.
 *
 * @example
 * ```typescript
 * const ctx = yield* getCtx
 * ctx.waitUntil(backgroundWork())
 * ```
 */
export const getCtx = Effect.gen(function* () {
  const ctx = yield* FiberRef.get(currentCtx)
  if (ctx === null) {
    return yield* Effect.die(
      "Cloudflare ctx not set. Ensure withCtx() wraps the handler.",
    )
  }
  return ctx
})

// ============================================================================
// Wrappers (Use at Request Boundary)
// ============================================================================

/**
 * Set Cloudflare env for the scope of an effect.
 *
 * Call this at the request boundary (in worker.ts fetch handler).
 */
export const withEnv = (env: Env) =>
  <A, E, R>(effect: Effect.Effect<A, E, R>) =>
    Effect.locally(currentEnv, env)(effect)

/**
 * Set Cloudflare ExecutionContext for the scope of an effect.
 *
 * Call this at the request boundary (in worker.ts fetch handler).
 */
export const withCtx = (ctx: ExecutionContext) =>
  <A, E, R>(effect: Effect.Effect<A, E, R>) =>
    Effect.locally(currentCtx, ctx)(effect)

// ============================================================================
// Utilities
// ============================================================================

/**
 * Schedule a background task that runs after the response is sent.
 *
 * Uses ctx.waitUntil() to keep the Worker alive while the effect runs.
 * Errors are logged but don't affect the response.
 *
 * ## Cloudflare Worker Lifecycle
 *
 * Normally, a Worker terminates as soon as the Response is returned.
 * ctx.waitUntil() tells Cloudflare to keep the Worker alive until the
 * provided Promise resolves.
 *
 * Common use cases:
 * - Analytics/logging that shouldn't block the response
 * - Cache warming
 * - Webhook notifications
 *
 * @example
 * ```typescript
 * yield* waitUntil(
 *   Effect.gen(function* () {
 *     yield* sendAnalytics(event)
 *   })
 * )
 * ```
 */
export const waitUntil = <A, E>(effect: Effect.Effect<A, E>): Effect.Effect<void> =>
  Effect.gen(function* () {
    const ctx = yield* getCtx
    ctx.waitUntil(
      Effect.runPromise(
        effect.pipe(
          Effect.tapErrorCause(Effect.logError),
          Effect.catchAll(() => Effect.void),
        ),
      ),
    )
  })
```

### `src/services/database.ts` (Enhanced Docs)

```typescript
/**
 * Database Service (Request-Scoped)
 *
 * Provides access to Drizzle ORM using Effect's FiberRef pattern.
 *
 * ## Why Per-Request Database Connections?
 *
 * Cloudflare Workers run in a serverless environment where:
 *
 * 1. **No persistent connections**: Workers are stateless and may be
 *    terminated at any time. Connection pools don't work.
 *
 * 2. **Isolate recycling**: The same isolate may handle multiple requests,
 *    but you can't rely on state persisting between them.
 *
 * 3. **TCP connections**: Each request opens a fresh TCP connection to the
 *    database and closes it when done.
 *
 * ## Connection Pattern
 *
 * ```
 * Request 1:  [open connection] → [query] → [close connection]
 * Request 2:  [open connection] → [query] → [close connection]
 * ```
 *
 * This is different from traditional Node.js apps that maintain connection
 * pools across requests.
 *
 * ## Why FiberRef for Database?
 *
 * Same reasoning as CloudflareEnv - we need per-request instances without
 * layer dependencies. See cloudflare.ts for detailed explanation.
 *
 * @module
 */
import * as Reactivity from "@effect/experimental/Reactivity"
import * as PgDrizzle from "@effect/sql-drizzle/Pg"
import { PgClient } from "@effect/sql-pg"
import * as SqlClient from "@effect/sql/SqlClient"
import type { PgRemoteDatabase } from "drizzle-orm/pg-proxy"
import { Effect, FiberRef, Redacted } from "effect"

/**
 * Type alias for the underlying Drizzle database instance.
 */
type DrizzleInstance = PgRemoteDatabase<Record<string, never>>

/**
 * FiberRef holding the current request's Drizzle instance.
 */
export const currentDrizzle = FiberRef.unsafeMake<DrizzleInstance | null>(null)

/**
 * Get the current Drizzle instance.
 *
 * Dies if called outside of withDatabase() scope.
 *
 * @example
 * ```typescript
 * const drizzle = yield* getDrizzle
 * const users = yield* drizzle.select().from(usersTable).limit(10)
 * ```
 */
export const getDrizzle = Effect.gen(function* () {
  const drizzle = yield* FiberRef.get(currentDrizzle)
  if (drizzle === null) {
    return yield* Effect.die(
      "Database not available. Ensure withDatabase() wraps the handler.",
    )
  }
  return drizzle
})

/**
 * Create a scoped database connection and make it available via FiberRef.
 *
 * ## Scope and Cleanup
 *
 * This uses Effect.scoped to ensure the connection is properly closed:
 *
 * ```typescript
 * withDatabase(url)(myEffect)
 * // ↓ expands to:
 * Effect.scoped(
 *   PgClient.make(...) → create connection
 *   Effect.locally(currentDrizzle, drizzle)(myEffect)
 *   // connection auto-closes when scope ends
 * )
 * ```
 *
 * ## Security Note
 *
 * The connection string should come from Cloudflare secrets (env.DATABASE_URL),
 * not hardcoded values.
 *
 * @param connectionString - PostgreSQL connection URL
 */
export const withDatabase = (connectionString: string) =>
  <A, E, R>(effect: Effect.Effect<A, E, R>) =>
    Effect.scoped(
      Effect.gen(function* () {
        // Create PgClient (scoped - auto-closes when scope ends)
        const pgClient = yield* PgClient.make({
          url: Redacted.make(connectionString),
        }).pipe(Effect.provide(Reactivity.layer))

        // Create Drizzle instance
        const drizzle = yield* PgDrizzle.make({
          casing: "snake_case",
        }).pipe(Effect.provideService(SqlClient.SqlClient, pgClient))

        // Run effect with Drizzle available via FiberRef
        return yield* Effect.locally(currentDrizzle, drizzle)(effect)
      }),
    )

// Re-export for type usage
export { PgDrizzle }
```

---

## Migration Steps

### Phase 1: File Renames (kebab-case)

```bash
# definition/
mv src/definition/WorkerApi.ts src/definition/worker-api.ts
mv src/definition/groups/HealthGroup.ts src/definition/groups/health-group.ts
mv src/definition/groups/UsersGroup.ts src/definition/groups/users-group.ts
mv src/definition/schemas/User.ts src/definition/schemas/user.ts

# api/
mv src/api/groups/HealthGroupLive.ts src/api/groups/health-group-live.ts
mv src/api/groups/UsersGroupLive.ts src/api/groups/users-group-live.ts
```

### Phase 2: Restructure to `/http`

1. Create `src/http/` directory
2. Merge `definition/groups/*.ts` with `api/groups/*.ts` into `http/groups/*.ts`
3. Move schemas and errors to `http/schemas/` and `http/errors/`
4. Create `http/api.ts` from `definition/WorkerApi.ts`
5. Delete old `definition/` and `api/` directories

### Phase 3: Update Imports

1. Update all imports to use `@/` paths
2. Update tsconfig.json paths if needed
3. Update barrel exports (index.ts files)

### Phase 4: Enhance Documentation

1. Add module-level docstrings explaining "why"
2. Add Cloudflare-specific context to each file
3. Ensure Effect patterns are explained for newcomers

### Phase 5: Cleanup

1. Remove `src/app.ts` (merge into `runtime.ts`)
2. Remove empty `src/errors/` directory
3. Rename `worker.ts` to `index.ts`
4. Rename `handler.ts` to `runtime.ts`
5. Update wrangler.toml if needed

---

## Test File Structure

```
test/
├── fixtures/
│   └── mock-services.ts          # Test utilities
├── unit/
│   ├── http/
│   │   └── groups/
│   │       ├── health.test.ts
│   │       └── users.test.ts
│   └── services/
│       ├── cloudflare.test.ts
│       └── database.test.ts
└── integration/
    └── api.test.ts
```

---

## Summary

| Change | Rationale |
|--------|-----------|
| Merge definition + api → http | Reduces confusion, keeps related code together |
| kebab-case files | Consistent naming, matches common conventions |
| @/ imports | No more relative path hell |
| Enhanced docstrings | Explains Cloudflare-specific "why" |
| Combined group files | Definition + handler in one place |
| Renamed entry files | Clearer purpose (index.ts, runtime.ts) |
